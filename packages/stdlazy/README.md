# stdlazy

A TypeScript-first lazy primitive that brings all the benefits of promises to sync and async lazy evaluation.

-   🦥 On-demand evaluation.
-   ⌚ Support for async initializers.
-   ⚙️ Multiple strongly-typed operators.
-   🫥 Use the `Lazy` type directly or return it as a `() => T` for a cleaner API.

## Install

Using yarn:

```typescript
yarn add stdlazy
```

Or npm:

```typescript
npm install --save stdlazy
```

## Pullables

A _Pullable_ is an object that provides a `pull()` that returns a value, which is also called its _pull value_. This method is expected to be idempotent – calling it more than once should return the same result and cause no side-effects. It’s defined in the same way as a _Thenable_.

Like a _Thenable_, a _Pullable_ should never produce another _Pullable_. If this would happen, it should instead **pull** it by invoking the `pull()` method, and return whatever it returns. This means _Pullables_ can be chained transparently.

This *pulling* is represented as the utility type `Pulled<T>`, which works just like `Awaited<T>` but for pullables. The related utility type `PulledAwaited<T>` returns the inner type of composition of *Pullables* and *Thenables*.

The `Lazy` object offered by `stdlazy` is a _Pullable_, but has a lot more functionality besides.

## Construction

Use the `lazy` factory function to wrap another function. This function can be sync or async, and it can even return another **Pullable** or `Lazy` instance.

```typescript
import { lazy } from "stdlazy"
import { readFile } from "fs/promises"

const lz = lazy(() => 1)

const lzFileContents = lazy(async () => {
    return readFile("./hello-world.txt", "utf8")
})

const lzLz = lazy(() => lazy1).pull() + 1
```

## Seamless promises

`stdlazy` uses a single `Lazy` primitive for both synchronous and asynchronous lazy evaluation. Async lazy evaluation is the same as a Lazy instance that returns a Promise.

In spite of this, the `lazy` factory function and all of the operators are overloaded to streamline working with these objects.

### The final form

The library guarantees that a composition of the `Lazy` and `Promise` types via operators and factory functions will be flattened into the `LazyAsync<T>` type, which is just `Lazy<Promise<T>>`. This is called the async **FINAL FORM**.

This means that something like `Promise<Lazy<Promise<Lazy<...>>>>` and so on will never be generated by the library. It will **always** be simplified into `LazyAsync<T>`.

## Operators

The `Lazy` type implements a lot of operators that work with _Pullables_.

All operators are overloaded to detect if the element type is a `Promise`. If so, the regular _pull value_ of the `Lazy` instance (the `Promise`) is replaced with the _awaited pull value_.

This allows the operators to transform values through both container types.

### Map

_Project the (awaited) pull value of a lazy instance._

```typescript
const lz = lazy(() => 1).map(x => x + 1)
console.log(lz.pull()) // 2

const asyncLz = lazy(async () => 1).map(x + 1)
console.log(await lz.pull()) // 2
```


The `map` operator creates a new `Lazy` instance, backed by an existing one. When it’s **pulled**, it will **pull** the existing instance and project its pull value using a function. However, it doesn’t do anything until the `pull` method is called.

If the projection returns another _Pullable_, its `pull` method will be called automatically. This allows chaining _Pullables_ just like chaining promises.

If either the current `Lazy` instance or the projection is async, the result will be a `LazyAsync`.

-   [`Array#map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
-   [`Promise#then`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)

### Do

_Perform an action with the (awaited) pull value of an instance._

```typescript
const lz = lazy(() => 1).do(console.log)
console.log(lz.pull()) // 1
```

The `do` operator produces a new `Lazy` instance, backed by an existing one. When it’s **pulled**, it will **pull** the existing instance and invoke the given callback before producing the value unchanged.

-   [`rxjs/do`](https://www.learnrxjs.io/learn-rxjs/operators/utility/do)

If either the current `Lazy` instance or the callback is async, the result will be `LazyAsync`.
### Zip

_Combines a `Lazy` with one or more pullables into a pullable returning an array._

```typescript
const lz1 = lazy(() => 1)
const lz2 = lazy(() => 2)
const zipped = lz1.zip(lz2)
console.log(zipped.pull()) // [1, 2]
```

The `zip` operator zips together an existing `Lazy` value with other _Pullables_, producing a single `Lazy` returning an array of their values, in the other in which they were specified.

-   [`Promise.all`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)
-   [`_.zip`](https://lodash.com/docs/4.17.15#zip)
-   [`rxjs/zip`](https://www.learnrxjs.io/learn-rxjs/operators/combination/zip)
-   Python [`zip`](https://docs.python.org/3.3/library/functions.html#zip)

If any of the `Lazy` instances involved are async, the result will be a `LazyAsync`.

### Assemble

_Combine multiple pullables into a single pullable returning an object_

```typescript
const lz1 = lazy(() => 1)
const lz2 = lazy(() => "hello")
const assembled = lz1.assemble({
    other: lz2
})
console.log(assembled.pull()) // {this: 1, other: "hello"}
```

The `assemble` operator combines an existing `Lazy` instance with other _Pullables_, given as an object with _Pullable_ values. It returns a single `Lazy` instance with the same keys and the values replaced by the pull values of each of them _Pullables_

The `Lazy` instance on which the operation was performed is considered to have the key `this`

If any of hte `Lazy` instances involved are async, the result will be `LazyAsync`.
